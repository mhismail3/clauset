//! Background event processor for continuous terminal buffering and activity tracking.
//!
//! This runs independently of WebSocket connections, ensuring terminal output
//! is always captured and activity updates are always broadcast, even when
//! no client is viewing the session.

use crate::state::AppState;
use clauset_core::ProcessEvent;
use std::sync::Arc;
use tokio::sync::broadcast;
use tracing::{debug, error, info};

/// Spawns a background task that processes all session events.
/// This ensures terminal output is buffered and activity is tracked
/// regardless of whether a WebSocket client is connected.
pub fn spawn_event_processor(state: Arc<AppState>) {
    let mut event_rx = state.session_manager.subscribe();

    tokio::spawn(async move {
        info!("Background event processor started");

        loop {
            match event_rx.recv().await {
                Ok(event) => {
                    process_event(&state, event).await;
                }
                Err(broadcast::error::RecvError::Lagged(n)) => {
                    // We missed some events due to slow processing
                    debug!("Event processor lagged by {} events", n);
                }
                Err(broadcast::error::RecvError::Closed) => {
                    info!("Event channel closed, stopping event processor");
                    break;
                }
            }
        }
    });
}

async fn process_event(state: &AppState, event: ProcessEvent) {
    match event {
        ProcessEvent::TerminalOutput { session_id, ref data } => {
            // Always store terminal output in buffer, regardless of WebSocket connections
            if let Some(activity) = state
                .session_manager
                .append_terminal_output(session_id, data)
                .await
            {
                // Broadcast activity update for dashboard real-time updates
                let _ = state.session_manager.event_sender().send(
                    ProcessEvent::ActivityUpdate {
                        session_id,
                        model: activity.model,
                        cost: activity.cost,
                        input_tokens: activity.input_tokens,
                        output_tokens: activity.output_tokens,
                        context_percent: activity.context_percent,
                        current_activity: activity.current_activity,
                        current_step: activity.current_step,
                        recent_actions: activity.recent_actions,
                    },
                );
            }
        }
        ProcessEvent::Exited { session_id, exit_code } => {
            info!("Session {} exited with code {:?}", session_id, exit_code);
            // Update session status to stopped
            let _ = state
                .session_manager
                .update_status(session_id, clauset_types::SessionStatus::Stopped);
        }
        ProcessEvent::Error { session_id, ref message } => {
            error!("Session {} error: {}", session_id, message);
        }
        // ActivityUpdate events are generated by this processor, no need to handle them here
        ProcessEvent::ActivityUpdate { .. } => {}
        // Claude events from stream-json mode
        ProcessEvent::Claude(_) => {}
    }
}
