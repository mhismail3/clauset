//! Background event processor for continuous terminal buffering and activity tracking.
//!
//! This runs independently of WebSocket connections, ensuring terminal output
//! is always captured and activity updates are always broadcast, even when
//! no client is viewing the session.

use crate::state::AppState;
use clauset_core::ProcessEvent;
use std::sync::Arc;
use tokio::sync::broadcast;
use tracing::{debug, error, info, instrument, warn};

/// Spawns a background task that processes all session events.
/// This ensures terminal output is buffered and activity is tracked
/// regardless of whether a WebSocket client is connected.
pub fn spawn_event_processor(state: Arc<AppState>) {
    let mut event_rx = state.session_manager.subscribe();

    tokio::spawn(async move {
        info!(target: "clauset::events", "Background event processor started");

        loop {
            match event_rx.recv().await {
                Ok(event) => {
                    process_event(&state, event).await;
                }
                Err(broadcast::error::RecvError::Lagged(n)) => {
                    // We missed some events due to slow processing - this is important to know
                    warn!(target: "clauset::events", "Event processor lagged by {} events - dashboard may miss activity updates", n);
                }
                Err(broadcast::error::RecvError::Closed) => {
                    info!(target: "clauset::events", "Event channel closed, stopping event processor");
                    break;
                }
            }
        }
    });
}

#[instrument(skip(state, event), fields(event_type = ?std::mem::discriminant(&event)))]
async fn process_event(state: &AppState, event: ProcessEvent) {
    match event {
        ProcessEvent::TerminalOutput { session_id, ref data } => {
            // Store terminal output in buffer and get sequence number for reliable streaming
            let (append_result, activity) = state
                .session_manager
                .append_terminal_output(session_id, data)
                .await;

            // Broadcast sequenced output for reliable streaming protocol
            // WebSocket handlers will convert this to TerminalChunk messages
            let _ = state.session_manager.event_sender().send(
                ProcessEvent::SequencedTerminalOutput {
                    session_id,
                    seq: append_result.seq,
                    data: data.clone(),
                    timestamp: append_result.timestamp,
                },
            );

            if let Some(activity) = activity {
                // Update interaction costs if they changed (handles late terminal output after Stop hook)
                state.interaction_processor.update_costs_from_session(
                    session_id,
                    activity.cost,
                    activity.input_tokens,
                    activity.output_tokens,
                );

                // Broadcast activity update for dashboard real-time updates
                let _ = state.session_manager.event_sender().send(
                    ProcessEvent::ActivityUpdate {
                        session_id,
                        model: activity.model,
                        cost: activity.cost,
                        input_tokens: activity.input_tokens,
                        output_tokens: activity.output_tokens,
                        context_percent: activity.context_percent,
                        current_activity: activity.current_activity,
                        current_step: activity.current_step,
                        recent_actions: activity.recent_actions,
                    },
                );
            }
        }
        ProcessEvent::Exited { session_id, exit_code } => {
            info!(target: "clauset::session", "Session {} exited with code {:?}", session_id, exit_code);
            // Persist activity data before updating status
            state.session_manager.persist_session_activity(session_id).await;
            // Update session status to stopped
            let _ = state
                .session_manager
                .update_status(session_id, clauset_types::SessionStatus::Stopped);
        }
        ProcessEvent::Error { session_id, ref message } => {
            error!(target: "clauset::session", "Session {} error: {}", session_id, message);
        }
        // ActivityUpdate events are generated by this processor, no need to handle them here
        ProcessEvent::ActivityUpdate { .. } => {}
        // SequencedTerminalOutput events are generated by this processor, no need to handle them here
        ProcessEvent::SequencedTerminalOutput { .. } => {}
        // Claude events from stream-json mode
        ProcessEvent::Claude(_) => {}
    }
}
